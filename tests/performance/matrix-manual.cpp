/**
 * ------------------------ Auto-generated Code ------------------------
 *           This code was generated by the Insieme Compiler
 * ---------------------------------------------------------------------
 */
#include <algorithm>
#include <alloca.h>
#include <allscale/runtime.hpp>
#include <chrono>
#include <cstdlib>
#include <iostream>
#include <stdbool.h>
#include <stdint.h>
#include <utility>

#ifdef __cplusplus
				/** Workaround for libstdc++/libc bug.
				 *  There's an inconsistency between libstdc++ and libc regarding whether
				 *  ::gets is declared or not, which is only evident when using certain
				 *  compilers and language settings
				 *  (tested positively with clang 3.9 --std=c++14 and libc 2.17).
				 */
				#include <initializer_list>  // force libstdc++ to include its config
				#undef _GLIBCXX_HAVE_GETS    // correct broken config
#endif

/* ------- Program Code --------- */

ALLSCALE_REGISTER_TREETURE_TYPE(int32_t)

struct __wi_main_name {
    static const char* name() { return "__wi_main"; }
};

struct __wi_main_variant_0;

struct __wi_main_variant_1;

struct __wi_main_can_split;

using __wi_main_work = allscale::work_item_description<int32_t, __wi_main_name, allscale::no_serialization, __wi_main_variant_0, __wi_main_variant_1, __wi_main_can_split >;

struct __wi_allscale_wi_1_variant_1;

struct __wi_allscale_wi_1_variant_0;

struct __wi_allscale_wi_1_can_split;

struct __wi_allscale_wi_1_name {
    static const char* name() { return "__wi_allscale_wi_1"; }
};

using __wi_allscale_wi_1_work = allscale::work_item_description<void, __wi_allscale_wi_1_name, allscale::no_serialization, __wi_allscale_wi_1_variant_0, __wi_allscale_wi_1_variant_1, __wi_allscale_wi_1_can_split >;

int32_t main(int32_t var_0, char** var_1) {
    return allscale::runtime::main_wrapper<__wi_main_work >(var_0, var_1);
}

struct matrix_1 {
    int32_t const& capture_0;
    int32_t**& capture_1;
    int32_t**& capture_2;
    int32_t**& capture_3;;
    matrix_1(int32_t const& var_1, int32_t**& var_2, int32_t**& var_3, int32_t**& var_4)
      : capture_0(var_1), capture_1(var_2), capture_2(var_3), capture_3(var_4)
    {}
    HPX_FORCEINLINE void operator()(int32_t var_1) const
    {
        for (int32_t var_2 = 0; var_2 < capture_0; ++var_2) {
            {
                capture_1[var_1][var_2] = 0;
                {
                    for (int32_t var_3 = 0; var_3 < capture_0; ++var_3) {
                        capture_1[var_1][var_2] += capture_2[var_1][var_3] * capture_3[var_3][var_2];
                    };
                };
            };
        };
    }
};

struct range_int {
    int32_t _begin;
    int32_t _end;;
    HPX_FORCEINLINE range_int() : _begin(0), _end(0) { }
    HPX_FORCEINLINE range_int(int32_t p2, int32_t p3)
      : _begin(p2), _end(p3)
    {
        if (empty()) {
            _end = _begin;
        };
    }
    HPX_FORCEINLINE bool empty() const
    {
        return size() == 0;
    }
    HPX_FORCEINLINE uint64_t size() const
    {
        return _begin < _end ? _end - _begin : 0;
    }
    HPX_FORCEINLINE int32_t begin() const
    {
        return _begin;
    }
    HPX_FORCEINLINE bool covers(range_int const& var_1) const
    {
        return _begin >= var_1._end || _begin <= var_1._begin && var_1._end <= _end;
    }
    HPX_FORCEINLINE int32_t end() const
    {
        return _end;
    }
    HPX_FORCEINLINE void forEach(matrix_1 const& p2) const
    {
        for (int32_t var_3 = _begin; var_3 < _end; ++var_3) {
            p2(var_3);
        }
    }
    HPX_FORCEINLINE range_int grow(range_int const& var_1, int32_t var_2) const
    {
        return range_int(
            std::max(_begin, var_1.begin() - var_2),
            std::min(_end, var_1.end() + var_2)
        );
    }
    HPX_FORCEINLINE range_int shrink(int32_t p2) const
    {
        return grow(*this, -p2);
    }
    HPX_FORCEINLINE std::pair<range_int, range_int > split() const
    {
        int32_t const& var_1 = _begin;
        int32_t const& var_2 = _end;
        int32_t var_3 = var_1 + (var_2 - var_1) / 2;
        return std::make_pair(range_int(var_1, var_3), range_int(var_3, var_2));
    }
};

struct __wi_allscale_wi_1_variant_1 {
    static hpx::util::unused_type execute(hpx::util::tuple<range_int, matrix_1> const& var_0)
    {
        hpx::util::get<0 >(var_0).forEach(hpx::util::get<1 >(var_0));
        return hpx::util::unused;
    }
    static constexpr bool valid = true;
};

/* ------- Function Definitions --------- */
struct __wi_allscale_wi_1_variant_0 {
    static allscale::treeture<void > execute(hpx::util::tuple<range_int, matrix_1> const& var_0)
    {
        std::pair<range_int, range_int > var_1 = hpx::util::get<0 >(var_0).split();
        range_int& var_2 = var_1.first;
        range_int& var_3 = var_1.second;
        return allscale::runtime::treeture_parallel(
            allscale::runtime::after(),
            allscale::spawn<__wi_allscale_wi_1_work >(
                var_2, hpx::util::get<1 >(var_0)
            ),
            allscale::spawn<__wi_allscale_wi_1_work >(
                var_3, hpx::util::get<1 >(var_0)
            )
        );
    }
    static constexpr bool valid = true;
};

/* ------- Function Definitions --------- */
struct __wi_allscale_wi_1_can_split {
    static bool call(hpx::util::tuple<range_int, matrix_1> const& var_0)
    {
        return hpx::util::get<0 >(var_0).size() > (uint64_t)1;
    }
};

allscale::treeture<void > allscale_fun_186(allscale::runtime::dependencies const& var_0, hpx::util::tuple<range_int, matrix_1> const& var_1) {
    return allscale::spawn_first_with_dependencies<__wi_allscale_wi_1_work >(var_0, hpx::util::get<0 >(var_1), hpx::util::get<1 >(var_1));
}
void IMP_execute(int32_t** var_0, int32_t** var_1, int32_t** var_2, int32_t var_3) {
    auto var_4 = std::chrono::system_clock::now();
    for (std::size_t i = 0; i < 10; ++i)
    {
        allscale::runtime::make_prec_operation<range_int, void >(
            hpx::util::tuple<matrix_1>{matrix_1{var_3, var_2, var_0, var_1}},
            &allscale_fun_186)(range_int(0, var_3)
        ).wait();
    }
    auto var_5 = std::chrono::system_clock::now();
    auto var_6 = var_5 - var_4;
    std::cout << var_6.count() / 10 << &std::endl;
}
int32_t** IMP_create_array_2d(int32_t var_0) {
    int32_t** var_1 = new int32_t*[var_0];
    {
        for (int32_t var_2 = 0; var_2 < var_0; ++var_2) {
            var_1[var_2] = new int32_t[var_0];
        };
    };
    return var_1;
}
int32_t** IMP_init(int32_t var_0) {
    int32_t** var_1 = IMP_create_array_2d(var_0);
    {
        for (int32_t var_2 = 0; var_2 < var_0; ++var_2) {
            {
                for (int32_t var_3 = 0; var_3 < var_0; ++var_3) {
                    var_1[var_2][var_3] = var_2 == var_3 ? 1 : 0;
                };
            };
        };
    };
    return var_1;
}
void IMP_check(int32_t** var_0, int32_t var_1) {
    int32_t var_2 = 0;
    while (var_2 < var_1) {
        {
            int32_t var_3 = 0;
            while (var_3 < var_1) {
                {
                    if (var_2 == var_3 && var_0[var_2][var_3] != 1) {
                        std::cerr << "mult error" << &std::endl;
                    };
                    if (var_2 != var_3 && var_0[var_2][var_3] != 0) {
                        std::cerr << "mult error" << &std::endl;
                    };
                };
                var_3++;
            };
        };
        var_2++;
    };
}
/* ------- Function Definitions --------- */
void IMP_delete_array(int32_t** var_0, int32_t var_1) {
    {
        for (int32_t var_2 = 0; var_2 < var_1; ++var_2) {
            delete[] var_0[var_2];
        };
    };
    delete[] var_0;
}
/* ------- Function Definitions --------- */
int32_t IMP_main(int32_t var_0, char** var_1) {
    int32_t var_2 = -1;
    {
        int32_t var_3 = 0;
        while (var_3 < var_0) {
            if ((int32_t)var_1[var_3][0] == (int32_t)((char)'-')) {
                {
                    for (int32_t var_4 = var_3 + 1; var_4 < var_0; ++var_4) {
                        var_1[var_4 - 1] = var_1[var_4];
                    };
                };
                var_0--;
            };
            var_3++;
        };
    };
    if (var_0 != 2) {
        std::cerr << "Usage: " << var_1[0] << " [MATRIX SIZE]" << &std::endl;
        var_2 = 700;
        std::cerr << "Setting default matrix size " << var_2 << &std::endl;
    } else {
        var_2 = atoi(var_1[1]);
        if (var_2 < 0) {
            std::cerr << "Matrix size has to be >= 0" << &std::endl;
            return 1;
        };
    };
    int32_t** var_5 = IMP_init(var_2);
    int32_t** var_6 = IMP_init(var_2);
    int32_t** var_7 = IMP_create_array_2d(var_2);
    IMP_execute(var_5, var_6, var_7, var_2);
    IMP_check(var_7, var_2);
    IMP_delete_array(var_5, var_2);
    IMP_delete_array(var_6, var_2);
    IMP_delete_array(var_7, var_2);
    return 0;
}

allscale::treeture<int32_t > allscale_fun_3(hpx::util::tuple<int32_t, char** > const& var_0) {
    return allscale::treeture<int32_t >(IMP_main(hpx::util::get<0 >(var_0), hpx::util::get<1 >(var_0)));
}

struct __wi_main_variant_0 {
    static allscale::treeture<int32_t > execute(hpx::util::tuple<int32_t, char** > const& var_0)
    {
        return allscale_fun_3(var_0);
    }
    static constexpr bool valid = true;
};

struct __wi_main_variant_1 {
    static allscale::treeture<int32_t > execute(hpx::util::tuple<int32_t, char** > const& var_0)
    {
        return allscale_fun_3(var_0);
    }
    static constexpr bool valid = true;
};

/* ------- Function Definitions --------- */
struct __wi_main_can_split {
    static bool call(hpx::util::tuple<int32_t, char** > const& var_0)
    {
        return false;
    }
};
