/**
 * ------------------------ Auto-generated Code ------------------------
 *           This code was generated by the Insieme Compiler
 * ---------------------------------------------------------------------
 */
#include <alloca.h>
#include <allscale/runtime.hpp>
#include <chrono>
#include <iostream>
#include <stdbool.h>
#include <stdint.h>
#include <utility>

#ifdef __cplusplus
#define INS_INIT(...) __VA_ARGS__
#else
#define INS_INIT(...) (__VA_ARGS__)
#endif
#ifdef __cplusplus
#include <new>
#define INS_INPLACE_INIT(Loc,Type) new(Loc) Type
#else
#define INS_INPLACE_INIT(Loc,Type) *(Loc) = (Type)
#endif
#ifdef __cplusplus
				/** Workaround for libstdc++/libc bug.
				 *  There's an inconsistency between libstdc++ and libc regarding whether
				 *  ::gets is declared or not, which is only evident when using certain
				 *  compilers and language settings
				 *  (tested positively with clang 3.9 --std=c++14 and libc 2.17).
				 */
				#include <initializer_list>  // force libstdc++ to include its config
				#undef _GLIBCXX_HAVE_GETS    // correct broken config
#endif

/* ------- Program Code --------- */

struct __wi_main_variant_1;
typedef struct __wi_main_variant_1 __wi_main_variant_1;

struct __wi_main_can_split;
typedef struct __wi_main_can_split __wi_main_can_split;

struct __wi_main_name {
    static const char* name() { return "__wi_main"; }
};

struct __wi_main_variant_0;
typedef struct __wi_main_variant_0 __wi_main_variant_0;

using __wi_main_work = allscale::work_item_description<int32_t, __wi_main_name, allscale::no_serialization, __wi_main_variant_0, __wi_main_variant_1, __wi_main_can_split >;

/* ------- Function Definitions --------- */
int32_t main() {
    return allscale::runtime::main_wrapper<__wi_main_work >();
}

ALLSCALE_REGISTER_TREETURE_TYPE(int32_t)
struct IMP_array_indices;
typedef struct IMP_array_indices IMP_array_indices;

struct IMP_array_indices {
    int32_t lo;
    int32_t hi;;
    ;
    ;
};

struct __wi_allscale_wi_1_can_split;
typedef struct __wi_allscale_wi_1_can_split __wi_allscale_wi_1_can_split;

struct __wi_allscale_wi_1_name {
    static const char* name() { return "__wi_allscale_wi_1"; }
};

struct __wi_allscale_wi_1_variant_0;
typedef struct __wi_allscale_wi_1_variant_0 __wi_allscale_wi_1_variant_0;

struct __wi_allscale_wi_1_variant_1;
typedef struct __wi_allscale_wi_1_variant_1 __wi_allscale_wi_1_variant_1;

using __wi_allscale_wi_1_work = allscale::work_item_description<void, __wi_allscale_wi_1_name, allscale::no_serialization, __wi_allscale_wi_1_variant_0, __wi_allscale_wi_1_variant_1, __wi_allscale_wi_1_can_split >;

/* ------- Function Definitions --------- */
allscale::treeture<void > allscale_fun_27(allscale::runtime::dependencies const& var_0, hpx::util::tuple<IMP_array_indices, int32_t* > const& var_1) {
    return allscale::spawn_with_dependencies<__wi_allscale_wi_1_work >(var_0, hpx::util::get<0 >(var_1), hpx::util::get<1 >(var_1));
}
/* ------- Function Definitions --------- */
void IMP_compute(int32_t* var_0, IMP_array_indices var_1) {
    std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<int64_t, std::ratio<1, 1000000000 > > > var_2 = (std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<int64_t, std::ratio<1, 1000000000 > > >&&)std::chrono::system_clock::now();
    auto var_3 = allscale::runtime::make_prec_operation<IMP_array_indices, void >(INS_INIT(hpx::util::tuple<int32_t* >){var_0}, &allscale_fun_27);
    var_3((IMP_array_indices const&)var_1).wait();
    std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<int64_t, std::ratio<1, 1000000000 > > > var_4 = (std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<int64_t, std::ratio<1, 1000000000 > > >&&)std::chrono::system_clock::now();
    std::chrono::duration<int64_t, std::ratio<1, 1000000000 > > var_5 = (std::chrono::duration<int64_t, std::ratio<1, 1000000000 > > const&)(var_4 - var_2);
    std::cout << var_5.count() << &std::endl;
}
struct allscale_type_3;
typedef struct allscale_type_3 allscale_type_3;

struct allscale_type_3 {
    int32_t data[1000000];;
};

/* ------- Global Variable Declaration ---------- */
allscale_type_3 a = {{0}};

/* ------- Function Definitions --------- */
int32_t IMP_main() {
    srand((uint32_t)time((int64_t*)0));
    {
        for (int32_t var_0 = 0; var_0 < 1000000; ++var_0) {
            a.data[var_0] = rand() % (1000 + 1);
        };
    };
    IMP_array_indices var_1;
    var_1.lo = 0;
    var_1.hi = 1000000 - 1;
    IMP_compute(a.data, (IMP_array_indices const&)var_1);
    return 0;
}
/* ------- Function Definitions --------- */
allscale::treeture<int32_t > allscale_fun_1(hpx::util::tuple<int, char** > const& var_0) {
    return allscale::treeture<int32_t >(IMP_main());
}
struct __wi_main_variant_1 {
    static allscale::treeture<int32_t > execute(hpx::util::tuple<int, char** > const& var_0);
    static constexpr bool valid = true;
};

/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
bool allscale_fun_36(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0) {
    return (*(IMP_array_indices*)(&hpx::util::get<0 >(var_0))).lo >= (*(IMP_array_indices*)(&hpx::util::get<0 >(var_0))).hi;
}
/* ------- Function Definitions --------- */
bool allscale_fun_40(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0) {
    return !allscale_fun_36(var_0);
}
struct __wi_allscale_wi_1_can_split {
    static bool call(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0);
};

bool __wi_allscale_wi_1_can_split::call(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0) {
    return allscale_fun_40(var_0);
}
/* ------- Function Definitions --------- */
int32_t IMP_partition(int32_t* var_0, IMP_array_indices var_1) {
    int32_t var_2;
    int32_t var_3 = var_0[var_1.hi];
    int32_t var_4 = var_1.lo;
    {
        for (int32_t var_5 = var_1.lo; var_5 < var_1.hi; ++var_5) {
            if (var_0[var_5] <= var_3) {
                var_2 = var_0[var_4];
                var_0[var_4] = var_0[var_5];
                var_0[var_5] = var_2;
                ++var_4;
            };
        };
    };
    var_2 = var_0[var_4];
    var_0[var_4] = var_0[var_1.hi];
    var_0[var_1.hi] = var_2;
    return var_4;
}
/* ------- Function Definitions --------- */
allscale::treeture<void > allscale_fun_31(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0) {
    IMP_array_indices var_1;
    IMP_array_indices var_2;
    int32_t var_3 = IMP_partition(*(int32_t* const*)(&hpx::util::get<1 >(var_0)), (IMP_array_indices const&)(*(IMP_array_indices*)(&hpx::util::get<0 >(var_0))));
    var_1.lo = (*(IMP_array_indices*)(&hpx::util::get<0 >(var_0))).lo;
    var_1.hi = var_3 - 1;
    var_2.lo = var_3 + 1;
    var_2.hi = (*(IMP_array_indices*)(&hpx::util::get<0 >(var_0))).hi;
    return allscale::runtime::treeture_parallel(allscale::runtime::after(), std::move(allscale::spawn_with_dependencies<__wi_allscale_wi_1_work >(allscale::runtime::after(), (IMP_array_indices const&)var_1, hpx::util::get<1 >(var_0))), std::move(allscale::spawn_with_dependencies<__wi_allscale_wi_1_work >(allscale::runtime::after(), (IMP_array_indices const&)var_2, hpx::util::get<1 >(var_0))));
}
/* ------- Function Definitions --------- */
allscale::treeture<void > allscale_fun_29(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0) {
    return allscale_fun_31(var_0);
}
struct __wi_allscale_wi_1_variant_0 {
    static allscale::treeture<void > execute(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0);
    static constexpr bool valid = true;
};

allscale::treeture<void > __wi_allscale_wi_1_variant_0::execute(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0) {
    return allscale_fun_29(var_0);
}
/* ------- Function Prototypes ---------- */
void rec(hpx::util::tuple<IMP_array_indices, int32_t* > const& p1);

/* ------- Function Definitions --------- */
allscale::treeture<void > allscale_fun_34(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0) {
    return rec(var_0), allscale::make_ready_treeture();
}
struct __wi_allscale_wi_1_variant_1 {
    static allscale::treeture<void > execute(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0);
    static constexpr bool valid = true;
};

/* ------- Function Definitions --------- */
void allscale_fun_39(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0) {
    IMP_array_indices var_1;
    IMP_array_indices var_2;
    int32_t var_3 = IMP_partition(*(int32_t* const*)(&hpx::util::get<1 >(var_0)), (IMP_array_indices const&)(*(IMP_array_indices*)(&hpx::util::get<0 >(var_0))));
    var_1.lo = (*(IMP_array_indices*)(&hpx::util::get<0 >(var_0))).lo;
    var_1.hi = var_3 - 1;
    var_2.lo = var_3 + 1;
    var_2.hi = (*(IMP_array_indices*)(&hpx::util::get<0 >(var_0))).hi;
    {
        rec(INS_INIT(hpx::util::tuple<IMP_array_indices, int32_t* >){(IMP_array_indices const&)var_1, hpx::util::get<1 >(var_0)});
        rec(INS_INIT(hpx::util::tuple<IMP_array_indices, int32_t* >){(IMP_array_indices const&)var_2, hpx::util::get<1 >(var_0)});
        return;
    };
}
/* ------- Function Definitions --------- */
void allscale_fun_38(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0) {
    return;
}
/* ------- Function Definitions --------- */
void rec(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0) {
    if (allscale_fun_36(var_0)) {
        return allscale_fun_38(var_0);
    } else {
        return allscale_fun_39(var_0);
    };
}
allscale::treeture<void > __wi_allscale_wi_1_variant_1::execute(hpx::util::tuple<IMP_array_indices, int32_t* > const& var_0) {
    return allscale_fun_34(var_0);
}
allscale::treeture<int32_t > __wi_main_variant_1::execute(hpx::util::tuple<int, char** > const& var_0) {
    return allscale_fun_1(var_0);
}
/* ------- Function Definitions --------- */
bool allscale_fun_52(hpx::util::tuple<int, char** > const& var_0) {
    return (bool)false;
}
struct __wi_main_can_split {
    static bool call(hpx::util::tuple<int, char** > const& var_0);
};

bool __wi_main_can_split::call(hpx::util::tuple<int, char** > const& var_0) {
    return allscale_fun_52(var_0);
}
struct __wi_main_variant_0 {
    static allscale::treeture<int32_t > execute(hpx::util::tuple<int, char** > const& var_0);
    static constexpr bool valid = true;
};

allscale::treeture<int32_t > __wi_main_variant_0::execute(hpx::util::tuple<int, char** > const& var_0) {
    return allscale_fun_1(var_0);
}

