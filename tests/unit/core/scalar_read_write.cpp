/**
 * ------------------------ Auto-generated Code ------------------------
 *           This code was generated by the Insieme Compiler
 * ---------------------------------------------------------------------
 */
#include <alloca.h>
#include <allscale/api/user/data/scalar.h>
#include <allscale/runtime.hpp>
#include <allscale/no_split.hpp>
#include <allscale/utils/assert.h>

#include <hpx/util/assert.hpp>
#include <hpx/util/lightweight_test.hpp>

#include <iostream>


ALLSCALE_REGISTER_TREETURE_TYPE(int32_t)

////////////////////////////////////////////////////////////////////////////////
// scalar read

struct scalar_read_name {
    static const char* name() { return "scalar_read"; }
};

struct scalar_read_process;

using scalar_read_work = allscale::work_item_description<
    void,
    scalar_read_name,
    allscale::no_serialization,
    allscale::no_split<void>,
    scalar_read_process
>;

struct scalar_read_process {
    template <typename Closure>
    static hpx::util::unused_type execute(Closure const& c)
    {
        auto s = hpx::util::get<0>(c);

        allscale::data_item_manager::get(s).set(12);

        return hpx::util::unused;
    }

    template <typename Closure>
    static hpx::util::tuple<
        allscale::data_item_requirement<allscale::api::user::data::Scalar<int32_t > >
    >
    get_requirements(Closure const& c)
    {
        return hpx::util::make_tuple(
            allscale::createDataItemRequirement(
                hpx::util::get<0>(c),
                allscale::api::user::data::detail::ScalarRegion(true),
                allscale::access_mode::ReadWrite
            )
        );
    }
    static constexpr bool valid = true;
};

////////////////////////////////////////////////////////////////////////////////
// main
struct main_process;

struct main_name {
    static const char* name() { return "main"; }
};

using main_work = allscale::work_item_description<
    int,
    main_name,
    allscale::no_serialization,
    allscale::no_split<int>,
    main_process>;

struct main_process
{
    template <typename Closure>
    static allscale::treeture<int> execute(Closure const& c)
    {
        allscale::data_item_reference<allscale::api::user::data::Scalar<int32_t > > s
            = allscale::data_item_manager::create<allscale::api::user::data::Scalar<int32_t > >();

        allscale::spawn<scalar_read_work >(s).wait();

        {
            auto lease = allscale::data_item_manager::acquire(
                allscale::createDataItemRequirement(
                    s,
                    allscale::api::user::data::detail::ScalarRegion(true),
                    allscale::access_mode::ReadOnly)
            );
            auto data = allscale::data_item_manager::get(s);
            HPX_TEST_EQ(data.get(), 12);
            allscale::data_item_manager::release(lease);
        }

        return allscale::make_ready_treeture(0);
    }
    static constexpr bool valid = true;
};

int main() {
    allscale::runtime::main_wrapper<main_work>();

    return hpx::util::report_errors();
}
